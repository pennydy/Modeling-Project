is.consonant <- FALSE
# phoneme.units <- vowel.units
num <- 12
} else {
is.consonant <- TRUE
# phoneme.units <- consonant.units
num <- 19
}
phoneme.units <- rep(0,num)
for (cycle in cycles){
input.weight <- phoneme * phoneme.excitatory.weight
# excitatory connection within the phoneme layer
for (n in 1:num){
# if it is a consonant
if (is.consonant) {
excitatory.input <- consonant.connections[, n] * input.weight
}
# if it is a vowel
else {
excitatory.input <- vowel.connections[, n] * input.weight
}
phoneme.units[n] <- phoneme.units[n] + sum(excitatory.input)
if(phoneme.units[n] < 0){
phoneme.units[n] <- 0
}
}
# inhibitory connection within the phoneme layer
inhibitory.activity <- numeric()
for(n in 1:num){
inhibitory.activity[n] <- sum(phoneme.units[-n] * phoneme.inhibitory.weight)
}
phoneme.units <- phoneme.units + inhibitory.activity
# activation from the phonolexical layer feedback -> not implemented
for(n in 1:21){
phonolexical.activity <- phonolexical.feedback * phonolexical.connections[, n]
if (i == 3 || i == 4){
phoneme.units <- phoneme.units + phonolexical.activity[38+(i-3)*12+1 : 38+(i-2)*12]
} else if (i == 1 || i == 2){
phoneme.units <- phoneme.units + phonolexical.activity[(i-1)*19+1 : i*19]
} else {
phoneme.units <- phoneme.units + phonolexical.activity[62+(i-5)*19+1 : 62+(i-4)*19]
}
}
for(n in 1:num){
if(phoneme.units[n] < 0){
phoneme.units[n] <- 0
}
}
}
# the response probability for consonants
phoneme.sum <- sum(phoneme.units)
# when it is the empty consonant/vowel -> keep them as zeros
if(phoneme.sum != 0){
phoneme.response.probability <- phoneme.units / phoneme.sum
} else {
phoneme.response.probability <- phoneme.units
}
phoneme.output <- c(phoneme.output, phoneme.response.probability)
}
# print(consonant.response.probability)
return (phoneme.output)
}
test.phonolexical.output <- rep(0, 100)
test.phoneme.output <- phoneme.activation(input.rain.sound, test.phonolexical.output)
warnings()
phonolexical.feedback <- rep(0, 100)
# inputs of the phonolexical level: 1. semantic activation (assuming seeing the picture will activate
# both the English and the Mandarin word for it); 2. phonemic activation
# output of the phonolexical level: how likely it is to be one of the 21 words (a vector of probabilities)
phonolexical.activation <- function(phoneme.input, visual.input){
phonolexical.units <- rep(0,21)
for (cycle in 1:cycles){
phoneme.input.weight <- phoneme.input * phonolexical.excitatory.weight
for (n in 1:21){
# excitatory inputs include both the output of the phoneme level
# as well as the activation at the semantic level
phoneme.excitatory.input <- phonolexical.connections[, n] * phoneme.input.weight
phonolexical.units[n] <- phonolexical.units[n] + sum(phoneme.excitatory.input)
if (n %% 3 == 1){
index <- (n %/% 3) * 2 + 1
phonolexical.units[n] <- phonolexical.units[n] + visual.input[index] * eng.excitatory.weight
phonolexical.units[n+1] <- phonolexical.units[n+1] + visual.input[index] * ma.excitatory.weight
} else if (n %% 3 == 0) {
index <- (n %/% 3) * 2
phonolexical.units[n] <- phonolexical.units[n] + visual.input[index] * eng.excitatory.weight
phonolexical.units[n-1] <- phonolexical.units[n-1] + visual.input[index] * ma.excitatory.weight
}
# print(phonolexical.units)
if(phonolexical.units[n] < 0){
phonolexical.units[n] <- 0
}
}
inhibitory.activity <- numeric()
for(n in 1:21){
inhibitory.activity[n] <- sum(phonolexical.units[-n] * phonolexical.inhibitory.weight)
}
phonolexical.units <- phonolexical.units + inhibitory.activity
for(n in 1:21){
if(phonolexical.units[n] < 0){
phonolexical.units[n] <- 0
}
}
# print(phonolexical.units)
# print(phonolexical.response.probability)
}
# the response probability for words at phonolexical level
phonolexical.response.probability <- phonolexical.units / sum(phonolexical.units)
return (phonolexical.response.probability)
}
test.phonolexical.output <- rep(0, 100)
test.phoneme.output <- phoneme.activation(input.rain.sound, test.phonolexical.output)
phonolexical.feedback <- rep(0, 100)
phonolexical.activity <- phonolexical.feedback * phonolexical.connections[, 1]
phonolexical.activity[38+(3-3)*12+1 : 38+(3-2)*12]
phonolexical.activity[38+(3-3)*12+1 : 38+(3-3)*12 + 12]
phonolexical.activity[38+(3-3)*12+1 : 38+(3-3)*12]
phonolexical.activity[(38+(3-3)*12+1) : (38+(3-3)*12 + 12)]
# activation function at the phoneme level
phoneme.activation <- function(sound.input, phonolexical.feedback){
phoneme.output <- c()
for(i in 1:6){
phoneme <- na.omit(sound.input[i])
if (i == 3 || i == 4) {
is.consonant <- FALSE
# phoneme.units <- vowel.units
num <- 12
} else {
is.consonant <- TRUE
# phoneme.units <- consonant.units
num <- 19
}
phoneme.units <- rep(0,num)
for (cycle in cycles){
input.weight <- phoneme * phoneme.excitatory.weight
# excitatory connection within the phoneme layer
for (n in 1:num){
# if it is a consonant
if (is.consonant) {
excitatory.input <- consonant.connections[, n] * input.weight
}
# if it is a vowel
else {
excitatory.input <- vowel.connections[, n] * input.weight
}
phoneme.units[n] <- phoneme.units[n] + sum(excitatory.input)
if(phoneme.units[n] < 0){
phoneme.units[n] <- 0
}
}
# inhibitory connection within the phoneme layer
inhibitory.activity <- numeric()
for(n in 1:num){
inhibitory.activity[n] <- sum(phoneme.units[-n] * phoneme.inhibitory.weight)
}
phoneme.units <- phoneme.units + inhibitory.activity
# activation from the phonolexical layer feedback -> not implemented
for(n in 1:21){
phonolexical.activity <- phonolexical.feedback * phonolexical.connections[, n]
if (i == 3 || i == 4){
phoneme.units <- phoneme.units + phonolexical.activity[(38+(i-3)*12+1) : (38+(i-2)*12)]
} else if (i == 1 || i == 2){
phoneme.units <- phoneme.units + phonolexical.activity[((i-1)*19+1) : (i*19)]
} else {
phoneme.units <- phoneme.units + phonolexical.activity[(62+(i-5)*19+1) : (62+(i-4)*19)]
}
}
for(n in 1:num){
if(phoneme.units[n] < 0){
phoneme.units[n] <- 0
}
}
}
# the response probability for consonants
phoneme.sum <- sum(phoneme.units)
# when it is the empty consonant/vowel -> keep them as zeros
if(phoneme.sum != 0){
phoneme.response.probability <- phoneme.units / phoneme.sum
} else {
phoneme.response.probability <- phoneme.units
}
phoneme.output <- c(phoneme.output, phoneme.response.probability)
}
# print(consonant.response.probability)
return (phoneme.output)
}
test.phonolexical.output <- rep(0, 100)
test.phoneme.output <- phoneme.activation(input.rain.sound, test.phonolexical.output)
print(test.phoneme.output)
test.phonolexical.output <- phonolexical.activation(na.omit(test.phoneme.output), input.rain.fish)
print(test.phonolexical.output)
test.phoneme.feedback.output <- phoneme.activation(input.empty.sound, test.phonolexical.output)
warnings()
# activation function at the phoneme level
phoneme.activation <- function(sound.input, phonolexical.feedback){
phoneme.output <- c()
for(i in 1:6){
phoneme <- na.omit(sound.input[i])
if (i == 3 || i == 4) {
is.consonant <- FALSE
# phoneme.units <- vowel.units
num <- 12
} else {
is.consonant <- TRUE
# phoneme.units <- consonant.units
num <- 19
}
phoneme.units <- rep(0,num)
for (cycle in cycles){
input.weight <- phoneme * phoneme.excitatory.weight
# excitatory connection within the phoneme layer
for (n in 1:num){
# if it is a consonant
if (is.consonant) {
excitatory.input <- consonant.connections[, n] * input.weight
}
# if it is a vowel
else {
excitatory.input <- vowel.connections[, n] * input.weight
}
phoneme.units[n] <- phoneme.units[n] + sum(excitatory.input)
if(phoneme.units[n] < 0){
phoneme.units[n] <- 0
}
}
# inhibitory connection within the phoneme layer
inhibitory.activity <- numeric()
for(n in 1:num){
inhibitory.activity[n] <- sum(phoneme.units[-n] * phoneme.inhibitory.weight)
}
phoneme.units <- phoneme.units + inhibitory.activity
# activation from the phonolexical layer feedback -> not implemented
for(n in 1:21){
phonolexical.activity <- phonolexical.feedback[n] * phonolexical.connections[, n]
if (i == 3 || i == 4){
phoneme.units <- phoneme.units + phonolexical.activity[(38+(i-3)*12+1) : (38+(i-2)*12)]
} else if (i == 1 || i == 2){
phoneme.units <- phoneme.units + phonolexical.activity[((i-1)*19+1) : (i*19)]
} else {
phoneme.units <- phoneme.units + phonolexical.activity[(62+(i-5)*19+1) : (62+(i-4)*19)]
}
}
for(n in 1:num){
if(phoneme.units[n] < 0){
phoneme.units[n] <- 0
}
}
}
# the response probability for consonants
phoneme.sum <- sum(phoneme.units)
# when it is the empty consonant/vowel -> keep them as zeros
if(phoneme.sum != 0){
phoneme.response.probability <- phoneme.units / phoneme.sum
} else {
phoneme.response.probability <- phoneme.units
}
phoneme.output <- c(phoneme.output, phoneme.response.probability)
}
# print(consonant.response.probability)
return (phoneme.output)
}
test.phonolexical.output <- rep(0, 100)
test.phoneme.output <- phoneme.activation(input.rain.sound, test.phonolexical.output)
print(test.phoneme.output)
test.phonolexical.output <- phonolexical.activation(na.omit(test.phoneme.output), input.rain.fish)
print(test.phonolexical.output)
test.phoneme.feedback.output <- phoneme.activation(input.empty.sound, test.phonolexical.output)
semantic.activation(test.phonolexical.output)
print(test.phoneme.feedback.output)
semantic.activation(test.phonolexical.output)
# since the picture is still being displayed
test.phonolexical.feedback.output <- phonolexical.activation(na.omit(test.phoneme.feedback.output),
input.rain.fish)
semantic.activation(test.phonolexical.feedback.output)
test.phonolexical.output <- rep(0, 100)
test.phoneme.output <- phoneme.activation(input.rain.sound, test.phonolexical.output)
print(test.phoneme.output)
test.phonolexical.output <- phonolexical.activation(na.omit(test.phoneme.output), input.rain.fish)
print(test.phonolexical.output)
test.semantic.output <- semantic.activation(test.phonolexical.output)
test.phoneme.feedback.output <- phoneme.activation(input.empty.sound, test.phonolexical.output)
print(test.phoneme.feedback.output)
print(test.phoneme.feedback.output)
# since the picture is still being displayed
test.phonolexical.feedback.output <- phonolexical.activation(na.omit(test.phoneme.feedback.output),
input.rain.fish)
test.semantic.final.output <- semantic.activation(test.phonolexical.feedback.output)
print(test.semantic.final.output)
# building the model
# a vector to record the activity each consonant/vowel
consonant.units <- rep(0, 19)
vowel.units <- rep(0,12)
phoneme.excitatory.weight <- 0.5
phoneme.inhibitory.weight <- -0.1
# a vector to record the activity of each CCVVCC word
phonolexical.units <- rep(0,21)
phonolexical.excitatory.weight <- 0.5
phonolexical.inhibitory.weight <- -0.01
eng.excitatory.weight <- 0.4
ma.excitatory.weight <- 0.3
semantic.units <- rep(0,14)
semantic.excitatory.weight <- 0.5
semantic.inhibitory.weight <- -0.1
# activation function at the phoneme level
phoneme.activation <- function(sound.input, phonolexical.feedback){
phoneme.output <- c()
for(i in 1:6){
phoneme <- na.omit(sound.input[i])
if (i == 3 || i == 4) {
is.consonant <- FALSE
phoneme.units <- vowel.units
num <- 12
} else {
is.consonant <- TRUE
phoneme.units <- consonant.units
num <- 19
}
# phoneme.units <- rep(0,num)
for (cycle in cycles){
input.weight <- phoneme * phoneme.excitatory.weight
# excitatory connection within the phoneme layer
for (n in 1:num){
# if it is a consonant
if (is.consonant) {
excitatory.input <- consonant.connections[, n] * input.weight
}
# if it is a vowel
else {
excitatory.input <- vowel.connections[, n] * input.weight
}
phoneme.units[n] <- phoneme.units[n] + sum(excitatory.input)
if(phoneme.units[n] < 0){
phoneme.units[n] <- 0
}
}
# inhibitory connection within the phoneme layer
inhibitory.activity <- numeric()
for(n in 1:num){
inhibitory.activity[n] <- sum(phoneme.units[-n] * phoneme.inhibitory.weight)
}
phoneme.units <- phoneme.units + inhibitory.activity
# activation from the phonolexical layer feedback -> not implemented
for(n in 1:21){
phonolexical.activity <- phonolexical.feedback[n] * phonolexical.connections[, n]
if (i == 3 || i == 4){
phoneme.units <- phoneme.units + phonolexical.activity[(38+(i-3)*12+1) : (38+(i-2)*12)]
} else if (i == 1 || i == 2){
phoneme.units <- phoneme.units + phonolexical.activity[((i-1)*19+1) : (i*19)]
} else {
phoneme.units <- phoneme.units + phonolexical.activity[(62+(i-5)*19+1) : (62+(i-4)*19)]
}
}
for(n in 1:num){
if(phoneme.units[n] < 0){
phoneme.units[n] <- 0
}
}
}
# the response probability for consonants
phoneme.sum <- sum(phoneme.units)
# when it is the empty consonant/vowel -> keep them as zeros
if(phoneme.sum != 0){
phoneme.response.probability <- phoneme.units / phoneme.sum
} else {
phoneme.response.probability <- phoneme.units
}
phoneme.output <- c(phoneme.output, phoneme.response.probability)
}
# print(consonant.response.probability)
return (phoneme.output)
}
# inputs of the phonolexical level: 1. semantic activation (assuming seeing the picture will activate
# both the English and the Mandarin word for it); 2. phonemic activation
# output of the phonolexical level: how likely it is to be one of the 21 words (a vector of probabilities)
phonolexical.activation <- function(phoneme.input, visual.input){
# phonolexical.units <- rep(0,21)
for (cycle in 1:cycles){
phoneme.input.weight <- phoneme.input * phonolexical.excitatory.weight
for (n in 1:21){
# excitatory inputs include both the output of the phoneme level
# as well as the activation at the semantic level
phoneme.excitatory.input <- phonolexical.connections[, n] * phoneme.input.weight
phonolexical.units[n] <- phonolexical.units[n] + sum(phoneme.excitatory.input)
if (n %% 3 == 1){
index <- (n %/% 3) * 2 + 1
phonolexical.units[n] <- phonolexical.units[n] + visual.input[index] * eng.excitatory.weight
phonolexical.units[n+1] <- phonolexical.units[n+1] + visual.input[index] * ma.excitatory.weight
} else if (n %% 3 == 0) {
index <- (n %/% 3) * 2
phonolexical.units[n] <- phonolexical.units[n] + visual.input[index] * eng.excitatory.weight
phonolexical.units[n-1] <- phonolexical.units[n-1] + visual.input[index] * ma.excitatory.weight
}
# print(phonolexical.units)
if(phonolexical.units[n] < 0){
phonolexical.units[n] <- 0
}
}
inhibitory.activity <- numeric()
for(n in 1:21){
inhibitory.activity[n] <- sum(phonolexical.units[-n] * phonolexical.inhibitory.weight)
}
phonolexical.units <- phonolexical.units + inhibitory.activity
for(n in 1:21){
if(phonolexical.units[n] < 0){
phonolexical.units[n] <- 0
}
}
# print(phonolexical.units)
# print(phonolexical.response.probability)
}
# the response probability for words at phonolexical level
phonolexical.response.probability <- phonolexical.units / sum(phonolexical.units)
return (phonolexical.response.probability)
}
# a vector to record the activity of each word at the semantic level
semantic.activation <- function(input){
# semantic.units <- rep(0,14)
for (cycle in 1:cycles){
input.weight <- input * semantic.excitatory.weight
# print(input.weight)
for (n in 1:14){
# the node for the Mandarin word (e.g. yu) should be connected to both nodes (target, rain
# and competetitor, fish) at the semantic layer -> change the representation of the lexical
# nodes
excitatory.input <- semantic.connections[, n] * input.weight
# print(excitatory.input)
semantic.units[n] <- semantic.units[n] + sum(excitatory.input)
# print(semantic.units)
if(semantic.units[n] < 0){
semantic.units[n] <- 0
}
}
# print(semantic.units)
inhibitory.activity <- numeric()
for(n in 1:14){
inhibitory.activity[n] <- sum(semantic.units[-n] * semantic.inhibitory.weight)
}
semantic.units <- semantic.units + inhibitory.activity
for(n in 1:14){
if(semantic.units[n] < 0){
semantic.units[n] <- 0
}
}
print(semantic.units/sum(semantic.units))
# the response probability for words at semantic level
}
semantic.response.probability <- semantic.units / sum(semantic.units)
return (semantic.response.probability)
}
visual.world <- function(auditory.input, visual.input){
phonolexical.output <- rep(0, 100)
phoneme.output <- phoneme.activation(auditory.input, phonolexical.output)
phonolexical.output <- phonolexical.activation(na.omit(phoneme.output), visual.input)
semantic.output <- semantic.activation(phonolexical.output)
return(semantic.output)
}
test.phonolexical.output <- rep(0, 100)
test.phoneme.output <- phoneme.activation(input.rain.sound, test.phonolexical.output)
print(test.phoneme.output)
test.phonolexical.output <- phonolexical.activation(na.omit(test.phoneme.output), input.rain.fish)
print(test.phonolexical.output)
test.semantic.output <- semantic.activation(test.phonolexical.output)
test.phoneme.feedback.output <- phoneme.activation(input.empty.sound, test.phonolexical.output)
print(test.phoneme.feedback.output)
# since the picture is still being displayed
test.phonolexical.feedback.output <- phonolexical.activation(na.omit(test.phoneme.feedback.output),
input.rain.fish)
test.semantic.final.output <- semantic.activation(test.phonolexical.feedback.output)
print(test.semantic.final.output)
test.phonolexical.output <- rep(0, 21)
test.phoneme.output <- phoneme.activation(input.rain.sound, test.phonolexical.output)
print(test.phoneme.output)
test.phonolexical.output <- phonolexical.activation(na.omit(test.phoneme.output), input.rain.fish)
print(test.phonolexical.output)
test.semantic.output <- semantic.activation(test.phonolexical.output)
test.phoneme.feedback.output <- phoneme.activation(input.empty.sound, test.phonolexical.output)
print(test.phoneme.feedback.output)
print(phonolexical.units)
# a vector to record the activity of each word at the semantic level
semantic.activation <- function(input){
# semantic.units <- rep(0,14)
for (cycle in 1:cycles){
input.weight <- input * semantic.excitatory.weight
# print(input.weight)
for (n in 1:14){
# the node for the Mandarin word (e.g. yu) should be connected to both nodes (target, rain
# and competetitor, fish) at the semantic layer -> change the representation of the lexical
# nodes
excitatory.input <- semantic.connections[, n] * input.weight
# print(excitatory.input)
semantic.units[n] <- semantic.units[n] + sum(excitatory.input)
# print(semantic.units)
if(semantic.units[n] < 0){
semantic.units[n] <- 0
}
}
# print(semantic.units)
inhibitory.activity <- numeric()
for(n in 1:14){
inhibitory.activity[n] <- sum(semantic.units[-n] * semantic.inhibitory.weight)
}
semantic.units <- semantic.units + inhibitory.activity
for(n in 1:14){
if(semantic.units[n] < 0){
semantic.units[n] <- 0
}
}
print(semantic.units/sum(semantic.units))
# the response probability for words at semantic level
}
semantic.response.probability <- semantic.units / sum(semantic.units)
return (semantic.response.probability)
}
